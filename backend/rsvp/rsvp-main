"""
RSVP backend module using Flask and SQLAlchemy.

Provides:
- model definitions (RSVP)
- endpoints: add, update, cancel, list, counts

"""

from datetime import datetime
from enum import Enum
from flask import Flask, jsonify, request, abort
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy import func, select
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import validates
from contextlib import contextmanager

app = Flask(__name__)
# Replace with your DB URI
app.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql://user:pass@localhost:5432/yourdb'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

db = SQLAlchemy(app)


# ---- Placeholder user & event models (adapt to your real models) ----
class User(db.Model):
    __tablename__ = 'users'
    user_id = db.Column(db.Integer, primary_key=True)
    bear_id = db.Column(db.String, unique=True)  # example
    email = db.Column(db.String, unique=True)


class Event(db.Model):
    __tablename__ = 'events'
    event_id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String, nullable=False)
    start_at = db.Column(db.DateTime, nullable=False)
    capacity = db.Column(db.Integer, nullable=True)  # if None => unlimited capacity
    # add other fields as needed


# ---- RSVP status enum ----
class RSVPStatus(Enum):
    GOING = 'going'
    INTERESTED = 'interested'
    NOT_GOING = 'not_going'


# ---- RSVP model ----
class RSVP(db.Model):
    __tablename__ = 'rsvps'
    rsvp_id = db.Column(db.Integer, primary_key=True)
    event_id = db.Column(db.Integer, db.ForeignKey('events.event_id', ondelete='CASCADE'), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('users.user_id', ondelete='CASCADE'), nullable=False)
    status = db.Column(db.Enum(RSVPStatus, name='rsvp_status'), nullable=False, default=RSVPStatus.GOING)
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)

    # ensures user can only RSVP once per event (creates unique constraint)
    __table_args__ = (db.UniqueConstraint('event_id', 'user_id', name='uq_event_user'),)

    # optional: basic validation of status field on model level
    @validates('status')
    def validate_status(self, key, value):
        if isinstance(value, RSVPStatus):
            return value
        if isinstance(value, str):
            try:
                return RSVPStatus(value)
            except ValueError:
                raise ValueError(f"Invalid RSVP status: {value}")
        raise ValueError(f"Unsupported type for status: {type(value)}")


# ---- Utility: login_required placeholder ----
def login_required(f):
    """
    Decorator placeholder. Replace with your project's auth decorator
    that sets `g.current_user` or returns user id in a session/token.
    For demo we assume a simple header "X-User-Id" with an integer.
    """
    from functools import wraps
    from flask import g

    @wraps(f)
    def decorated(*args, **kwargs):
        uid = request.headers.get('X-User-Id')
        if not uid:
            return jsonify({'error': 'Authentication required'}), 401
        try:
            user = User.query.get(int(uid))
        except Exception:
            user = None
        if not user:
            return jsonify({'error': 'Invalid user'}), 401
        g.current_user = user
        return f(*args, **kwargs)
    return decorated


# ---- Transaction helper ----
@contextmanager
def transactional_session():
    """
    Yields a session and commits or rolls back automatically.
    Use this to ensure atomic operations for capacity checks and updates.
    """
    session = db.session
    try:
        yield session
        session.commit()
    except Exception:
        session.rollback()
        raise


# ---- Endpoint: Add RSVP ----
@app.route('/api/events/<int:event_id>/rsvp', methods=['POST'])
@login_required
def add_rsvp(event_id):
    """
    Add an RSVP for the logged-in user for `event_id`.
    Body (JSON): { "status": "going" | "interested" | "not_going" }
    Handles capacity check if event.capacity is set.
    """
    from flask import g
    payload = request.get_json() or {}
    status_str = payload.get('status', 'going')

    # validate status
    try:
        status = RSVPStatus(status_str)
    except ValueError:
        return jsonify({'error': 'Invalid status value'}), 400

    user = g.current_user

    # Check event exists, and capacity (with transaction for concurrency safety)
    with transactional_session() as session:
        # Acquire a FOR UPDATE lock on the event row when checking capacity to avoid races
        event = session.query(Event).filter(Event.event_id == event_id).with_for_update().first()
        if not event:
            return jsonify({'error': 'Event not found'}), 404

        # If capacity is set, ensure not exceeded.
        if event.capacity is not None:
            # Current confirmed 'going' count
            going_count = session.query(func.count(RSVP.rsvp_id)).filter(
                RSVP.event_id == event_id, RSVP.status == RSVPStatus.GOING
            ).scalar() or 0

            # If user is already RSVP'd as going, we still allow updates below. For capacity,
            # a new 'going' must not push count > capacity.
            # If user is changing to 'going' but capacity full, reject
            existing = session.query(RSVP).filter_by(event_id=event_id, user_id=user.user_id).first()
            would_be_going = (status == RSVPStatus.GOING) and (not (existing and existing.status == RSVPStatus.GOING))
            if would_be_going and going_count >= event.capacity:
                return jsonify({'error': 'Event is at capacity'}), 409

        # Insert or update RSVP (upsert-like logic)
        try:
            rsvp = session.query(RSVP).filter_by(event_id=event_id, user_id=user.user_id).first()
            if rsvp:
                # If RSVP exists, update
                rsvp.status = status
                rsvp.updated_at = datetime.utcnow()
                session.add(rsvp)
                action = 'updated'
            else:
                # Create new RSVP
                rsvp = RSVP(event_id=event_id, user_id=user.user_id, status=status)
                session.add(rsvp)
                action = 'created'
            # commit happens via context manager
        except IntegrityError as e:
            session.rollback()
            return jsonify({'error': 'RSVP conflict'}), 409

    return jsonify({
        'result': 'success',
        'action': action,
        'rsvp': {
            'event_id': event_id,
            'user_id': user.user_id,
            'status': rsvp.status.value,
            'created_at': rsvp.created_at.isoformat(),
            'updated_at': rsvp.updated_at.isoformat() if rsvp.updated_at else None
        }
    }), 200


# ---- Endpoint: Update RSVP status explicitly ----
@app.route('/api/events/<int:event_id>/rsvp', methods=['PUT'])
@login_required
def update_rsvp(event_id):
    """
    Update RSVP status for a user (same payload as POST).
    Returns 404 if RSVP doesn't exist.
    """
    from flask import g
    payload = request.get_json() or {}
    status_str = payload.get('status')

    if not status_str:
        return jsonify({'error': 'status required'}), 400

    try:
        status = RSVPStatus(status_str)
    except ValueError:
        return jsonify({'error': 'Invalid status value'}), 400

    user = g.current_user

    with transactional_session() as session:
        rsvp = session.query(RSVP).filter_by(event_id=event_id, user_id=user.user_id).first()
        if not rsvp:
            return jsonify({'error': 'RSVP not found'}), 404

        # If changing to going, check capacity similarly as in add_rsvp
        event = session.query(Event).filter(Event.event_id == event_id).with_for_update().first()
        if not event:
            return jsonify({'error': 'Event not found'}), 404

        if event.capacity is not None:
            going_count = session.query(func.count(RSVP.rsvp_id)).filter(
                RSVP.event_id == event_id, RSVP.status == RSVPStatus.GOING
            ).scalar() or 0
            would_be_going = (status == RSVPStatus.GOING) and (rsvp.status != RSVPStatus.GOING)
            if would_be_going and going_count >= event.capacity:
                return jsonify({'error': 'Event is at capacity'}), 409

        rsvp.status = status
        rsvp.updated_at = datetime.utcnow()
        session.add(rsvp)

    return jsonify({'result': 'updated', 'status': rsvp.status.value}), 200


# ---- Endpoint: Cancel RSVP ----
@app.route('/api/events/<int:event_id>/rsvp', methods=['DELETE'])
@login_required
def cancel_rsvp(event_id):
    """
    Cancel RSVP for the current user by removing the record.
    Could alternatively set status to 'not_going' instead of deleting.
    """
    from flask import g
    user = g.current_user

    with transactional_session() as session:
        rsvp = session.query(RSVP).filter_by(event_id=event_id, user_id=user.user_id).first()
        if not rsvp:
            return jsonify({'error': 'RSVP not found'}), 404
        session.delete(rsvp)

    return jsonify({'result': 'deleted'}), 200


# ---- Endpoint: Get RSVP counts for an event ----
@app.route('/api/events/<int:event_id>/rsvp/counts', methods=['GET'])
def get_rsvp_counts(event_id):
    """
    Returns counts per status for the event, e.g. {'going': 10, 'interested': 3}
    """
    # aggregate counts by status
    counts = db.session.query(RSVP.status, func.count(RSVP.rsvp_id)).filter(
        RSVP.event_id == event_id
    ).group_by(RSVP.status).all()

    # convert enum->string and return
    result = {status.value: count for (status, count) in counts}
    # ensure all statuses returned (even zero)
    for s in RSVPStatus:
        result.setdefault(s.value, 0)

    return jsonify({'event_id': event_id, 'counts': result}), 200


# ---- Endpoint: List RSVPs for an event (organizer use) ----
@app.route('/api/events/<int:event_id>/rsvp/list', methods=['GET'])
@login_required
def list_event_rsvps(event_id):
    """
    Return list of RSVPs for a given event.
    Access can be restricted to event organizers; here it is left to login_required only.
    """
    rsvps = db.session.query(RSVP).filter_by(event_id=event_id).all()
    items = [{
        'user_id': r.user_id,
        'status': r.status.value,
        'created_at': r.created_at.isoformat(),
        'updated_at': r.updated_at.isoformat() if r.updated_at else None
    } for r in rsvps]
    return jsonify({'event_id': event_id, 'rsvps': items}), 200


# ---- Endpoint: List events a user RSVP'd to (profile) ----
@app.route('/api/users/me/rsvps', methods=['GET'])
@login_required
def list_user_rsvps():
    """
    Returns a list of events the current user has RSVP'd to, with status.
    Useful for user profile pages.
    """
    from flask import g
    user = g.current_user
    join_q = db.session.query(RSVP, Event).join(Event, RSVP.event_id == Event.event_id).filter(RSVP.user_id == user.user_id)

    items = []
    for rsvp, event in join_q.all():
        items.append({
            'event_id': event.event_id,
            'title': event.title,
            'start_at': event.start_at.isoformat(),
            'status': rsvp.status.value
        })
    return jsonify({'user_id': user.user_id, 'rsvps': items}), 200


# ---- Helper: delete cascade behavior ----
# Note: We configured ON DELETE CASCADE in the DDL. When deleting an event or user,
# related RSVPs will be automatically removed by DB. If you want to handle it in-app,
# add explicit deletes in transactional sessions before deleting user/event.


# ---- Run app (for testing) ----
if __name__ == '__main__':
    app.run(debug=True)
